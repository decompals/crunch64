use clap::{Parser, ValueEnum};
use crunch64::Crunch64Error;
use std::{
    fs::File,
    io::{BufReader, BufWriter, Read, Write},
    path::PathBuf,
    process,
};

#[derive(ValueEnum, Copy, Clone, Debug, PartialEq, Eq)]
enum Command {
    Compress,
    Decompress,
}

#[derive(ValueEnum, Copy, Clone, Debug, PartialEq, Eq, Hash)]
enum CompressionType {
    Yay0,
    Yaz0,
    Mio0,
    Gzip,
    Vpk0,
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[arg()]
    command: Command,
    #[arg(ignore_case = true)]
    format: CompressionType,
    #[arg()]
    in_path: String,
    #[arg()]
    out_path: String,
    /// Compression level for gzip (4-9)
    #[arg(long, default_value_t = 9)]
    level: usize,
    /// Output gzip blocks more frequently
    #[arg(long)]
    small_mem: bool,
}

fn compress(args: &Args, bytes: &[u8]) -> Result<Box<[u8]>, Crunch64Error> {
    match args.format {
        CompressionType::Yay0 => crunch64::yay0::compress(bytes),
        CompressionType::Yaz0 => crunch64::yaz0::compress(bytes),
        CompressionType::Mio0 => crunch64::mio0::compress(bytes),
        CompressionType::Gzip => crunch64::gzip::compress(bytes, args.level, args.small_mem),
        CompressionType::Vpk0 => crunch64::vpk0::compress(bytes),
        // _ => Err(Crunch64Error::UnsupportedCompressionType),
    }
}

fn decompress(args: &Args, bytes: &[u8]) -> Result<Box<[u8]>, Crunch64Error> {
    match args.format {
        CompressionType::Yay0 => crunch64::yay0::decompress(bytes),
        CompressionType::Yaz0 => crunch64::yaz0::decompress(bytes),
        CompressionType::Mio0 => crunch64::mio0::decompress(bytes),
        CompressionType::Vpk0 => crunch64::vpk0::decompress(bytes),
        _ => Err(Crunch64Error::UnsupportedCompressionType),
    }
}

fn main() {
    let args = Args::parse();

    let file_bytes = read_file_bytes(&args.in_path);

    let out_bytes = match args.command {
        Command::Compress => match compress(&args, file_bytes.as_slice()) {
            Ok(bytes) => bytes,
            Err(error) => {
                eprintln!("{:?}", error);
                process::exit(1);
            }
        },
        Command::Decompress => match decompress(&args, file_bytes.as_slice()) {
            Ok(bytes) => bytes,
            Err(error) => {
                eprintln!("{:?}", error);
                process::exit(1);
            }
        },
    };

    let mut buf_writer = match File::create(args.out_path) {
        Ok(file) => BufWriter::new(file),
        Err(_error) => {
            eprintln!("Failed to create file");
            process::exit(1);
        }
    };

    let _ = buf_writer.write_all(&out_bytes);
}

pub fn read_file_bytes<P: Into<PathBuf>>(path: P) -> Vec<u8> {
    let file = match File::open(path.into()) {
        Ok(file) => file,
        Err(_error) => {
            eprintln!("Failed to open file");
            process::exit(1);
        }
    };

    let mut buf_reader = BufReader::new(file);
    let mut buffer = Vec::new();

    let _ = buf_reader.read_to_end(&mut buffer);

    buffer
}
